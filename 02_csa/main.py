import autogen
import json
import logging
import os
import sys

# Append the project root to sys.path for module discovery
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "../")))

# Import configuration settings from model_config module
from model_config import *

# Configure logging to log both to a file and the console
logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("debug.log"),  # Log output to debug.log file
        logging.StreamHandler(),  # Output logs to console
    ],
)

# Define a prompt for the assistant agent to classify user queries
agent_prompt = """You are a helpful assistant that classifies and resolves user queries.
Query Classes:
1. Technical Support
2. Account Management
3. Billing Issues
4. Product Information
5. General Inquiry

For each query:
1. Understand the user's request
2. Classify it into one of the above categories
3. Provide an appropriate resolution
4. Format response as: 
   Category: [class]
   Resolution: [detailed response]
"""

# Create an assistant agent for classifying queries using the prompt
assistant = autogen.AssistantAgent(
    name="query_classifier",  # Name of the assistant agent
    system_message=agent_prompt,  # Instruction prompt for the assistant
    llm_config=llm_config,  # Language model configuration
)

# Create a user proxy agent for interfacing with the user
user = autogen.UserProxyAgent(
    name="user_proxy",  # Identifier for the user proxy
    max_consecutive_auto_reply=1,  # Limit consecutive automated replies
    is_termination_msg=lambda msg: "TERMINATE"
    in msg.get("content", ""),  # Termination check
    human_input_mode="NEVER",  # Disable interactive human input
    code_execution_config=False,  # Disable code execution configuration
)

# Sample user query for testing
user_query = ["How do I reset my password?"]

# Initialize a list to store conversation messages
conversation_messages = []

def process_query(user_input):
    """
    Process a user query by initiating a chat with the assistant agent.

    Parameters:
        user_input (str): The query input from the user.

    Returns:
        str: The response from the assistant agent, or a default message.
    """
    try:
        # Initiate a chat with the assistant agent with an explicit timeout
        user.initiate_chat(
            assistant,
            message=user_input,
            timeout=600,  # Set timeout to 600 seconds
        )

        # Retrieve chat history for the assistant
        chat_history = user.chat_messages[assistant]
        logging.debug(
            f"Message count: {len(chat_history)}"
        )  # Log the count of messages

        # Return the content of the latest message, if available
        return chat_history[-1]["content"] if chat_history else "No response"
    except TimeoutError:
        # Return timeout error message if query processing exceeds allowed time
        return "Query processing timed out. Please try again."

# Process the sample query
process_query(user_query[0])

# Access the full chat history for the assistant agent
chat_messages = user.chat_messages[assistant]

# Store each message (role and content) in the conversation history list
for message in chat_messages:
    conversation_messages.append(
        {"role": message["role"], "content": message["content"]}
    )

# Save the conversation history to a JSON file for record keeping
with open("conversation_history.json", "w") as f:
    json.dump(conversation_messages, f, indent=2)

# Log key events in the chat flow
logging.info("Starting chat session")
logging.debug(f"User Query: {user_query}")
logging.debug(f"Assistant Response: {chat_messages[-1]['content']}")
logging.info("Chat session completed successfully")

# Log additional debug information regarding query classification
logging.debug(f"Classifying query: {user_query}")
logging.debug(f"Assigned category: {chat_messages[-1]['content']}")

# If no messages were generated, log an error
if not chat_messages:
    logging.error("No response generated by the assistant.")